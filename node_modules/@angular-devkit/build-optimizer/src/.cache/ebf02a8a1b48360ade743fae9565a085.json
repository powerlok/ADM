{"remainingRequest":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\html2canvas\\dist\\npm\\renderer\\CanvasRenderer.js","dependencies":[{"path":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\html2canvas\\dist\\npm\\renderer\\CanvasRenderer.js","mtime":1549298997502},{"path":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1549298993416},{"path":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1549298984589}],"contextDependencies":[],"result":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _Path = require('../drawing/Path');\r\n\r\nvar _textDecoration = require('../parsing/textDecoration');\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar addColorStops = function addColorStops(gradient, canvasGradient) {\r\n    var maxStop = Math.max.apply(null, gradient.colorStops.map(function (colorStop) {\r\n        return colorStop.stop;\r\n    }));\r\n    var f = 1 / Math.max(1, maxStop);\r\n    gradient.colorStops.forEach(function (colorStop) {\r\n        canvasGradient.addColorStop(f * colorStop.stop, colorStop.color.toString());\r\n    });\r\n};\r\n\r\nvar CanvasRenderer = function () {\r\n    function CanvasRenderer(canvas) {\r\n        _classCallCheck(this, CanvasRenderer);\r\n\r\n        this.canvas = canvas ? canvas : document.createElement('canvas');\r\n    }\r\n\r\n    _createClass(CanvasRenderer, [{\r\n        key: 'render',\r\n        value: function render(options) {\r\n            this.ctx = this.canvas.getContext('2d');\r\n            this.options = options;\r\n            this.canvas.width = Math.floor(options.width * options.scale);\r\n            this.canvas.height = Math.floor(options.height * options.scale);\r\n            this.canvas.style.width = options.width + 'px';\r\n            this.canvas.style.height = options.height + 'px';\r\n\r\n            this.ctx.scale(this.options.scale, this.options.scale);\r\n            this.ctx.translate(-options.x, -options.y);\r\n            this.ctx.textBaseline = 'bottom';\r\n            options.logger.log('Canvas renderer initialized (' + options.width + 'x' + options.height + ' at ' + options.x + ',' + options.y + ') with scale ' + this.options.scale);\r\n        }\r\n    }, {\r\n        key: 'clip',\r\n        value: function clip(clipPaths, callback) {\r\n            var _this = this;\r\n\r\n            if (clipPaths.length) {\r\n                this.ctx.save();\r\n                clipPaths.forEach(function (path) {\r\n                    _this.path(path);\r\n                    _this.ctx.clip();\r\n                });\r\n            }\r\n\r\n            callback();\r\n\r\n            if (clipPaths.length) {\r\n                this.ctx.restore();\r\n            }\r\n        }\r\n    }, {\r\n        key: 'drawImage',\r\n        value: function drawImage(image, source, destination) {\r\n            this.ctx.drawImage(image, source.left, source.top, source.width, source.height, destination.left, destination.top, destination.width, destination.height);\r\n        }\r\n    }, {\r\n        key: 'drawShape',\r\n        value: function drawShape(path, color) {\r\n            this.path(path);\r\n            this.ctx.fillStyle = color.toString();\r\n            this.ctx.fill();\r\n        }\r\n    }, {\r\n        key: 'fill',\r\n        value: function fill(color) {\r\n            this.ctx.fillStyle = color.toString();\r\n            this.ctx.fill();\r\n        }\r\n    }, {\r\n        key: 'getTarget',\r\n        value: function getTarget() {\r\n            this.canvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);\r\n            return Promise.resolve(this.canvas);\r\n        }\r\n    }, {\r\n        key: 'path',\r\n        value: function path(_path) {\r\n            var _this2 = this;\r\n\r\n            this.ctx.beginPath();\r\n            if (Array.isArray(_path)) {\r\n                _path.forEach(function (point, index) {\r\n                    var start = point.type === _Path.PATH.VECTOR ? point : point.start;\r\n                    if (index === 0) {\r\n                        _this2.ctx.moveTo(start.x, start.y);\r\n                    } else {\r\n                        _this2.ctx.lineTo(start.x, start.y);\r\n                    }\r\n\r\n                    if (point.type === _Path.PATH.BEZIER_CURVE) {\r\n                        _this2.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);\r\n                    }\r\n                });\r\n            } else {\r\n                this.ctx.arc(_path.x + _path.radius, _path.y + _path.radius, _path.radius, 0, Math.PI * 2, true);\r\n            }\r\n\r\n            this.ctx.closePath();\r\n        }\r\n    }, {\r\n        key: 'rectangle',\r\n        value: function rectangle(x, y, width, height, color) {\r\n            this.ctx.fillStyle = color.toString();\r\n            this.ctx.fillRect(x, y, width, height);\r\n        }\r\n    }, {\r\n        key: 'renderLinearGradient',\r\n        value: function renderLinearGradient(bounds, gradient) {\r\n            var linearGradient = this.ctx.createLinearGradient(bounds.left + gradient.direction.x1, bounds.top + gradient.direction.y1, bounds.left + gradient.direction.x0, bounds.top + gradient.direction.y0);\r\n\r\n            addColorStops(gradient, linearGradient);\r\n            this.ctx.fillStyle = linearGradient;\r\n            this.ctx.fillRect(bounds.left, bounds.top, bounds.width, bounds.height);\r\n        }\r\n    }, {\r\n        key: 'renderRadialGradient',\r\n        value: function renderRadialGradient(bounds, gradient) {\r\n            var _this3 = this;\r\n\r\n            var x = bounds.left + gradient.center.x;\r\n            var y = bounds.top + gradient.center.y;\r\n\r\n            var radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, gradient.radius.x);\r\n            if (!radialGradient) {\r\n                return;\r\n            }\r\n\r\n            addColorStops(gradient, radialGradient);\r\n            this.ctx.fillStyle = radialGradient;\r\n\r\n            if (gradient.radius.x !== gradient.radius.y) {\r\n                // transforms for elliptical radial gradient\r\n                var midX = bounds.left + 0.5 * bounds.width;\r\n                var midY = bounds.top + 0.5 * bounds.height;\r\n                var f = gradient.radius.y / gradient.radius.x;\r\n                var invF = 1 / f;\r\n\r\n                this.transform(midX, midY, [1, 0, 0, f, 0, 0], function () {\r\n                    return _this3.ctx.fillRect(bounds.left, invF * (bounds.top - midY) + midY, bounds.width, bounds.height * invF);\r\n                });\r\n            } else {\r\n                this.ctx.fillRect(bounds.left, bounds.top, bounds.width, bounds.height);\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderRepeat',\r\n        value: function renderRepeat(path, image, imageSize, offsetX, offsetY) {\r\n            this.path(path);\r\n            this.ctx.fillStyle = this.ctx.createPattern(this.resizeImage(image, imageSize), 'repeat');\r\n            this.ctx.translate(offsetX, offsetY);\r\n            this.ctx.fill();\r\n            this.ctx.translate(-offsetX, -offsetY);\r\n        }\r\n    }, {\r\n        key: 'renderTextNode',\r\n        value: function renderTextNode(textBounds, color, font, textDecoration, textShadows) {\r\n            var _this4 = this;\r\n\r\n            this.ctx.font = [font.fontStyle, font.fontVariant, font.fontWeight, font.fontSize, font.fontFamily].join(' ');\r\n\r\n            textBounds.forEach(function (text) {\r\n                _this4.ctx.fillStyle = color.toString();\r\n                if (textShadows && text.text.trim().length) {\r\n                    textShadows.slice(0).reverse().forEach(function (textShadow) {\r\n                        _this4.ctx.shadowColor = textShadow.color.toString();\r\n                        _this4.ctx.shadowOffsetX = textShadow.offsetX * _this4.options.scale;\r\n                        _this4.ctx.shadowOffsetY = textShadow.offsetY * _this4.options.scale;\r\n                        _this4.ctx.shadowBlur = textShadow.blur;\r\n\r\n                        _this4.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);\r\n                    });\r\n                } else {\r\n                    _this4.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);\r\n                }\r\n\r\n                if (textDecoration !== null) {\r\n                    var textDecorationColor = textDecoration.textDecorationColor || color;\r\n                    textDecoration.textDecorationLine.forEach(function (textDecorationLine) {\r\n                        switch (textDecorationLine) {\r\n                            case _textDecoration.TEXT_DECORATION_LINE.UNDERLINE:\r\n                                // Draws a line at the baseline of the font\r\n                                // TODO As some browsers display the line as more than 1px if the font-size is big,\r\n                                // need to take that into account both in position and size\r\n                                var _options$fontMetrics$ = _this4.options.fontMetrics.getMetrics(font),\r\n                                    baseline = _options$fontMetrics$.baseline;\r\n\r\n                                _this4.rectangle(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1, textDecorationColor);\r\n                                break;\r\n                            case _textDecoration.TEXT_DECORATION_LINE.OVERLINE:\r\n                                _this4.rectangle(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1, textDecorationColor);\r\n                                break;\r\n                            case _textDecoration.TEXT_DECORATION_LINE.LINE_THROUGH:\r\n                                // TODO try and find exact position for line-through\r\n                                var _options$fontMetrics$2 = _this4.options.fontMetrics.getMetrics(font),\r\n                                    middle = _options$fontMetrics$2.middle;\r\n\r\n                                _this4.rectangle(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1, textDecorationColor);\r\n                                break;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }, {\r\n        key: 'resizeImage',\r\n        value: function resizeImage(image, size) {\r\n            if (image.width === size.width && image.height === size.height) {\r\n                return image;\r\n            }\r\n\r\n            var canvas = this.canvas.ownerDocument.createElement('canvas');\r\n            canvas.width = size.width;\r\n            canvas.height = size.height;\r\n            var ctx = canvas.getContext('2d');\r\n            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);\r\n            return canvas;\r\n        }\r\n    }, {\r\n        key: 'setOpacity',\r\n        value: function setOpacity(opacity) {\r\n            this.ctx.globalAlpha = opacity;\r\n        }\r\n    }, {\r\n        key: 'transform',\r\n        value: function transform(offsetX, offsetY, matrix, callback) {\r\n            this.ctx.save();\r\n            this.ctx.translate(offsetX, offsetY);\r\n            this.ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n            this.ctx.translate(-offsetX, -offsetY);\r\n\r\n            callback();\r\n\r\n            this.ctx.restore();\r\n        }\r\n    }]);\r\n\r\n    return CanvasRenderer;\r\n}();\r\n\r\nexports.default = CanvasRenderer;",null]}