{"remainingRequest":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/html2canvas/dist/npm/Renderer.js","dependencies":[{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/html2canvas/dist/npm/Renderer.js","mtime":1549298997000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/cache-loader/dist/cjs.js","mtime":1549298993000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1549298984000}],"contextDependencies":[],"result":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _Bounds = require('./Bounds');\r\n\r\nvar _Font = require('./Font');\r\n\r\nvar _Gradient = require('./Gradient');\r\n\r\nvar _TextContainer = require('./TextContainer');\r\n\r\nvar _TextContainer2 = _interopRequireDefault(_TextContainer);\r\n\r\nvar _background = require('./parsing/background');\r\n\r\nvar _border = require('./parsing/border');\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar Renderer = function () {\r\n    function Renderer(target, options) {\r\n        _classCallCheck(this, Renderer);\r\n\r\n        this.target = target;\r\n        this.options = options;\r\n        target.render(options);\r\n    }\r\n\r\n    _createClass(Renderer, [{\r\n        key: 'renderNode',\r\n        value: function renderNode(container) {\r\n            if (container.isVisible()) {\r\n                this.renderNodeBackgroundAndBorders(container);\r\n                this.renderNodeContent(container);\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderNodeContent',\r\n        value: function renderNodeContent(container) {\r\n            var _this = this;\r\n\r\n            var callback = function callback() {\r\n                if (container.childNodes.length) {\r\n                    container.childNodes.forEach(function (child) {\r\n                        if (child instanceof _TextContainer2.default) {\r\n                            var style = child.parent.style;\r\n                            _this.target.renderTextNode(child.bounds, style.color, style.font, style.textDecoration, style.textShadow);\r\n                        } else {\r\n                            _this.target.drawShape(child, container.style.color);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (container.image) {\r\n                    var _image = _this.options.imageStore.get(container.image);\r\n                    if (_image) {\r\n                        var contentBox = (0, _Bounds.calculateContentBox)(container.bounds, container.style.padding, container.style.border);\r\n                        var _width = typeof _image.width === 'number' && _image.width > 0 ? _image.width : contentBox.width;\r\n                        var _height = typeof _image.height === 'number' && _image.height > 0 ? _image.height : contentBox.height;\r\n                        if (_width > 0 && _height > 0) {\r\n                            _this.target.clip([(0, _Bounds.calculatePaddingBoxPath)(container.curvedBounds)], function () {\r\n                                _this.target.drawImage(_image, new _Bounds.Bounds(0, 0, _width, _height), contentBox);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            var paths = container.getClipPaths();\r\n            if (paths.length) {\r\n                this.target.clip(paths, callback);\r\n            } else {\r\n                callback();\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderNodeBackgroundAndBorders',\r\n        value: function renderNodeBackgroundAndBorders(container) {\r\n            var _this2 = this;\r\n\r\n            var HAS_BACKGROUND = !container.style.background.backgroundColor.isTransparent() || container.style.background.backgroundImage.length;\r\n\r\n            var hasRenderableBorders = container.style.border.some(function (border) {\r\n                return border.borderStyle !== _border.BORDER_STYLE.NONE && !border.borderColor.isTransparent();\r\n            });\r\n\r\n            var callback = function callback() {\r\n                var backgroundPaintingArea = (0, _background.calculateBackgroungPaintingArea)(container.curvedBounds, container.style.background.backgroundClip);\r\n\r\n                if (HAS_BACKGROUND) {\r\n                    _this2.target.clip([backgroundPaintingArea], function () {\r\n                        if (!container.style.background.backgroundColor.isTransparent()) {\r\n                            _this2.target.fill(container.style.background.backgroundColor);\r\n                        }\r\n\r\n                        _this2.renderBackgroundImage(container);\r\n                    });\r\n                }\r\n\r\n                container.style.border.forEach(function (border, side) {\r\n                    if (border.borderStyle !== _border.BORDER_STYLE.NONE && !border.borderColor.isTransparent()) {\r\n                        _this2.renderBorder(border, side, container.curvedBounds);\r\n                    }\r\n                });\r\n            };\r\n\r\n            if (HAS_BACKGROUND || hasRenderableBorders) {\r\n                var paths = container.parent ? container.parent.getClipPaths() : [];\r\n                if (paths.length) {\r\n                    this.target.clip(paths, callback);\r\n                } else {\r\n                    callback();\r\n                }\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderBackgroundImage',\r\n        value: function renderBackgroundImage(container) {\r\n            var _this3 = this;\r\n\r\n            container.style.background.backgroundImage.slice(0).reverse().forEach(function (backgroundImage) {\r\n                if (backgroundImage.source.method === 'url' && backgroundImage.source.args.length) {\r\n                    _this3.renderBackgroundRepeat(container, backgroundImage);\r\n                } else if (/gradient/i.test(backgroundImage.source.method)) {\r\n                    _this3.renderBackgroundGradient(container, backgroundImage);\r\n                }\r\n            });\r\n        }\r\n    }, {\r\n        key: 'renderBackgroundRepeat',\r\n        value: function renderBackgroundRepeat(container, background) {\r\n            var image = this.options.imageStore.get(background.source.args[0]);\r\n            if (image) {\r\n                var backgroundPositioningArea = (0, _background.calculateBackgroungPositioningArea)(container.style.background.backgroundOrigin, container.bounds, container.style.padding, container.style.border);\r\n                var backgroundImageSize = (0, _background.calculateBackgroundSize)(background, image, backgroundPositioningArea);\r\n                var position = (0, _background.calculateBackgroundPosition)(background.position, backgroundImageSize, backgroundPositioningArea);\r\n                var _path = (0, _background.calculateBackgroundRepeatPath)(background, position, backgroundImageSize, backgroundPositioningArea, container.bounds);\r\n\r\n                var _offsetX = Math.round(backgroundPositioningArea.left + position.x);\r\n                var _offsetY = Math.round(backgroundPositioningArea.top + position.y);\r\n                this.target.renderRepeat(_path, image, backgroundImageSize, _offsetX, _offsetY);\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderBackgroundGradient',\r\n        value: function renderBackgroundGradient(container, background) {\r\n            var backgroundPositioningArea = (0, _background.calculateBackgroungPositioningArea)(container.style.background.backgroundOrigin, container.bounds, container.style.padding, container.style.border);\r\n            var backgroundImageSize = (0, _background.calculateGradientBackgroundSize)(background, backgroundPositioningArea);\r\n            var position = (0, _background.calculateBackgroundPosition)(background.position, backgroundImageSize, backgroundPositioningArea);\r\n            var gradientBounds = new _Bounds.Bounds(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y), backgroundImageSize.width, backgroundImageSize.height);\r\n\r\n            var gradient = (0, _Gradient.parseGradient)(container, background.source, gradientBounds);\r\n            if (gradient) {\r\n                switch (gradient.type) {\r\n                    case _Gradient.GRADIENT_TYPE.LINEAR_GRADIENT:\r\n                        // $FlowFixMe\r\n                        this.target.renderLinearGradient(gradientBounds, gradient);\r\n                        break;\r\n                    case _Gradient.GRADIENT_TYPE.RADIAL_GRADIENT:\r\n                        // $FlowFixMe\r\n                        this.target.renderRadialGradient(gradientBounds, gradient);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderBorder',\r\n        value: function renderBorder(border, side, curvePoints) {\r\n            this.target.drawShape((0, _Bounds.parsePathForBorder)(curvePoints, side), border.borderColor);\r\n        }\r\n    }, {\r\n        key: 'renderStack',\r\n        value: function renderStack(stack) {\r\n            var _this4 = this;\r\n\r\n            if (stack.container.isVisible()) {\r\n                var _opacity = stack.getOpacity();\r\n                if (_opacity !== this._opacity) {\r\n                    this.target.setOpacity(stack.getOpacity());\r\n                    this._opacity = _opacity;\r\n                }\r\n\r\n                var _transform = stack.container.style.transform;\r\n                if (_transform !== null) {\r\n                    this.target.transform(stack.container.bounds.left + _transform.transformOrigin[0].value, stack.container.bounds.top + _transform.transformOrigin[1].value, _transform.transform, function () {\r\n                        return _this4.renderStackContent(stack);\r\n                    });\r\n                } else {\r\n                    this.renderStackContent(stack);\r\n                }\r\n            }\r\n        }\r\n    }, {\r\n        key: 'renderStackContent',\r\n        value: function renderStackContent(stack) {\r\n            var _splitStackingContext = splitStackingContexts(stack),\r\n                _splitStackingContext2 = _slicedToArray(_splitStackingContext, 5),\r\n                negativeZIndex = _splitStackingContext2[0],\r\n                zeroOrAutoZIndexOrTransformedOrOpacity = _splitStackingContext2[1],\r\n                positiveZIndex = _splitStackingContext2[2],\r\n                nonPositionedFloats = _splitStackingContext2[3],\r\n                nonPositionedInlineLevel = _splitStackingContext2[4];\r\n\r\n            var _splitDescendants = splitDescendants(stack),\r\n                _splitDescendants2 = _slicedToArray(_splitDescendants, 2),\r\n                inlineLevel = _splitDescendants2[0],\r\n                nonInlineLevel = _splitDescendants2[1];\r\n\r\n            // https://www.w3.org/TR/css-position-3/#painting-order\r\n            // 1. the background and borders of the element forming the stacking context.\r\n\r\n\r\n            this.renderNodeBackgroundAndBorders(stack.container);\r\n            // 2. the child stacking contexts with negative stack levels (most negative first).\r\n            negativeZIndex.sort(sortByZIndex).forEach(this.renderStack, this);\r\n            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:\r\n            this.renderNodeContent(stack.container);\r\n            nonInlineLevel.forEach(this.renderNode, this);\r\n            // 4. All non-positioned floating descendants, in tree order. For each one of these,\r\n            // treat the element as if it created a new stacking context, but any positioned descendants and descendants\r\n            // which actually create a new stacking context should be considered part of the parent stacking context,\r\n            // not this new one.\r\n            nonPositionedFloats.forEach(this.renderStack, this);\r\n            // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.\r\n            nonPositionedInlineLevel.forEach(this.renderStack, this);\r\n            inlineLevel.forEach(this.renderNode, this);\r\n            // 6. All positioned, opacity or transform descendants, in tree order that fall into the following categories:\r\n            //  All positioned descendants with 'z-index: auto' or 'z-index: 0', in tree order.\r\n            //  For those with 'z-index: auto', treat the element as if it created a new stacking context,\r\n            //  but any positioned descendants and descendants which actually create a new stacking context should be\r\n            //  considered part of the parent stacking context, not this new one. For those with 'z-index: 0',\r\n            //  treat the stacking context generated atomically.\r\n            //\r\n            //  All opacity descendants with opacity less than 1\r\n            //\r\n            //  All transform descendants with transform other than none\r\n            zeroOrAutoZIndexOrTransformedOrOpacity.forEach(this.renderStack, this);\r\n            // 7. Stacking contexts formed by positioned descendants with z-indices greater than or equal to 1 in z-index\r\n            // order (smallest first) then tree order.\r\n            positiveZIndex.sort(sortByZIndex).forEach(this.renderStack, this);\r\n        }\r\n    }, {\r\n        key: 'render',\r\n        value: function render(stack) {\r\n            var _this5 = this;\r\n\r\n            if (this.options.backgroundColor) {\r\n                this.target.rectangle(this.options.x, this.options.y, this.options.width, this.options.height, this.options.backgroundColor);\r\n            }\r\n            this.renderStack(stack);\r\n            var target = this.target.getTarget();\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                return target.then(function (output) {\r\n                    _this5.options.logger.log('Render completed');\r\n                    return output;\r\n                });\r\n            }\r\n            return target;\r\n        }\r\n    }]);\r\n\r\n    return Renderer;\r\n}();\r\n\r\nexports.default = Renderer;\r\n\r\n\r\nvar splitDescendants = function splitDescendants(stack) {\r\n    var inlineLevel = [];\r\n    var nonInlineLevel = [];\r\n\r\n    var length = stack.children.length;\r\n    for (var i = 0; i < length; i++) {\r\n        var child = stack.children[i];\r\n        if (child.isInlineLevel()) {\r\n            inlineLevel.push(child);\r\n        } else {\r\n            nonInlineLevel.push(child);\r\n        }\r\n    }\r\n    return [inlineLevel, nonInlineLevel];\r\n};\r\n\r\nvar splitStackingContexts = function splitStackingContexts(stack) {\r\n    var negativeZIndex = [];\r\n    var zeroOrAutoZIndexOrTransformedOrOpacity = [];\r\n    var positiveZIndex = [];\r\n    var nonPositionedFloats = [];\r\n    var nonPositionedInlineLevel = [];\r\n    var length = stack.contexts.length;\r\n    for (var i = 0; i < length; i++) {\r\n        var child = stack.contexts[i];\r\n        if (child.container.isPositioned() || child.container.style.opacity < 1 || child.container.isTransformed()) {\r\n            if (child.container.style.zIndex.order < 0) {\r\n                negativeZIndex.push(child);\r\n            } else if (child.container.style.zIndex.order > 0) {\r\n                positiveZIndex.push(child);\r\n            } else {\r\n                zeroOrAutoZIndexOrTransformedOrOpacity.push(child);\r\n            }\r\n        } else {\r\n            if (child.container.isFloating()) {\r\n                nonPositionedFloats.push(child);\r\n            } else {\r\n                nonPositionedInlineLevel.push(child);\r\n            }\r\n        }\r\n    }\r\n    return [negativeZIndex, zeroOrAutoZIndexOrTransformedOrOpacity, positiveZIndex, nonPositionedFloats, nonPositionedInlineLevel];\r\n};\r\n\r\nvar sortByZIndex = function sortByZIndex(a, b) {\r\n    if (a.container.style.zIndex.order > b.container.style.zIndex.order) {\r\n        return 1;\r\n    } else if (a.container.style.zIndex.order < b.container.style.zIndex.order) {\r\n        return -1;\r\n    }\r\n\r\n    return a.container.index > b.container.index ? 1 : -1;\r\n};",null]}