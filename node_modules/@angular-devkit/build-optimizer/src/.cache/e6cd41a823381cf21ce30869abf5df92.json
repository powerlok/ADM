{"remainingRequest":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/css-line-break/dist/LineBreak.js","dependencies":[{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/css-line-break/dist/LineBreak.js","mtime":1549298995000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/cache-loader/dist/cjs.js","mtime":1549298993000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1549298984000}],"contextDependencies":[],"result":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\nexports.LineBreaker = exports.inlineBreakOpportunities = exports.lineBreakAtIndex = exports.codePointsToCharacterClasses = exports.UnicodeTrie = exports.BREAK_ALLOWED = exports.BREAK_NOT_ALLOWED = exports.BREAK_MANDATORY = exports.classes = exports.LETTER_NUMBER_MODIFIER = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _Trie = require('./Trie');\r\n\r\nvar _linebreakTrie = require('./linebreak-trie');\r\n\r\nvar _linebreakTrie2 = _interopRequireDefault(_linebreakTrie);\r\n\r\nvar _Util = require('./Util');\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar LETTER_NUMBER_MODIFIER = exports.LETTER_NUMBER_MODIFIER = 50;\r\n\r\n// Non-tailorable Line Breaking Classes\r\nvar BK = 1; //  Cause a line break (after)\r\nvar CR = 2; //  Cause a line break (after), except between CR and LF\r\nvar LF = 3; //  Cause a line break (after)\r\nvar CM = 4; //  Prohibit a line break between the character and the preceding character\r\nvar NL = 5; //  Cause a line break (after)\r\nvar SG = 6; //  Do not occur in well-formed text\r\nvar WJ = 7; //  Prohibit line breaks before and after\r\nvar ZW = 8; //  Provide a break opportunity\r\nvar GL = 9; //  Prohibit line breaks before and after\r\nvar SP = 10; // Enable indirect line breaks\r\nvar ZWJ = 11; // Prohibit line breaks within joiner sequences\r\n// Break Opportunities\r\nvar B2 = 12; //  Provide a line break opportunity before and after the character\r\nvar BA = 13; //  Generally provide a line break opportunity after the character\r\nvar BB = 14; //  Generally provide a line break opportunity before the character\r\nvar HY = 15; //  Provide a line break opportunity after the character, except in numeric context\r\nvar CB = 16; //   Provide a line break opportunity contingent on additional information\r\n// Characters Prohibiting Certain Breaks\r\nvar CL = 17; //  Prohibit line breaks before\r\nvar CP = 18; //  Prohibit line breaks before\r\nvar EX = 19; //  Prohibit line breaks before\r\nvar IN = 20; //  Allow only indirect line breaks between pairs\r\nvar NS = 21; //  Allow only indirect line breaks before\r\nvar OP = 22; //  Prohibit line breaks after\r\nvar QU = 23; //  Act like they are both opening and closing\r\n// Numeric Context\r\nvar IS = 24; //  Prevent breaks after any and before numeric\r\nvar NU = 25; //  Form numeric expressions for line breaking purposes\r\nvar PO = 26; //  Do not break following a numeric expression\r\nvar PR = 27; //  Do not break in front of a numeric expression\r\nvar SY = 28; //  Prevent a break before; and allow a break after\r\n// Other Characters\r\nvar AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID\r\nvar AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters\r\nvar CJ = 31; //  Treat as NS or ID for strict or normal breaking.\r\nvar EB = 32; //  Do not break from following Emoji Modifier\r\nvar EM = 33; //  Do not break from preceding Emoji Base\r\nvar H2 = 34; //  Form Korean syllable blocks\r\nvar H3 = 35; //  Form Korean syllable blocks\r\nvar HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic\r\nvar ID = 37; //  Break before or after; except in some numeric context\r\nvar JL = 38; //  Form Korean syllable blocks\r\nvar JV = 39; //  Form Korean syllable blocks\r\nvar JT = 40; //  Form Korean syllable blocks\r\nvar RI = 41; //  Keep pairs together. For pairs; break before and after other classes\r\nvar SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis\r\nvar XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions\r\n\r\nvar classes = exports.classes = {\r\n    BK: BK,\r\n    CR: CR,\r\n    LF: LF,\r\n    CM: CM,\r\n    NL: NL,\r\n    SG: SG,\r\n    WJ: WJ,\r\n    ZW: ZW,\r\n    GL: GL,\r\n    SP: SP,\r\n    ZWJ: ZWJ,\r\n    B2: B2,\r\n    BA: BA,\r\n    BB: BB,\r\n    HY: HY,\r\n    CB: CB,\r\n    CL: CL,\r\n    CP: CP,\r\n    EX: EX,\r\n    IN: IN,\r\n    NS: NS,\r\n    OP: OP,\r\n    QU: QU,\r\n    IS: IS,\r\n    NU: NU,\r\n    PO: PO,\r\n    PR: PR,\r\n    SY: SY,\r\n    AI: AI,\r\n    AL: AL,\r\n    CJ: CJ,\r\n    EB: EB,\r\n    EM: EM,\r\n    H2: H2,\r\n    H3: H3,\r\n    HL: HL,\r\n    ID: ID,\r\n    JL: JL,\r\n    JV: JV,\r\n    JT: JT,\r\n    RI: RI,\r\n    SA: SA,\r\n    XX: XX\r\n};\r\n\r\nvar BREAK_MANDATORY = exports.BREAK_MANDATORY = '!';\r\nvar BREAK_NOT_ALLOWED = exports.BREAK_NOT_ALLOWED = '×';\r\nvar BREAK_ALLOWED = exports.BREAK_ALLOWED = '÷';\r\nvar UnicodeTrie = exports.UnicodeTrie = (0, _Trie.createTrieFromBase64)(_linebreakTrie2.default);\r\n\r\nvar ALPHABETICS = [AL, HL];\r\nvar HARD_LINE_BREAKS = [BK, CR, LF, NL];\r\nvar SPACE = [SP, ZW];\r\nvar PREFIX_POSTFIX = [PR, PO];\r\nvar LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE);\r\nvar KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];\r\nvar HYPHEN = [HY, BA];\r\n\r\nvar codePointsToCharacterClasses = exports.codePointsToCharacterClasses = function codePointsToCharacterClasses(codePoints) {\r\n    var lineBreak = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'strict';\r\n\r\n    var types = [];\r\n    var indicies = [];\r\n    var categories = [];\r\n    codePoints.forEach(function (codePoint, index) {\r\n        var classType = UnicodeTrie.get(codePoint);\r\n        if (classType > LETTER_NUMBER_MODIFIER) {\r\n            categories.push(true);\r\n            classType -= LETTER_NUMBER_MODIFIER;\r\n        } else {\r\n            categories.push(false);\r\n        }\r\n\r\n        if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {\r\n            // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0\r\n            if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {\r\n                indicies.push(index);\r\n                return types.push(CB);\r\n            }\r\n        }\r\n\r\n        if (classType === CM || classType === ZWJ) {\r\n            // LB10 Treat any remaining combining mark or ZWJ as AL.\r\n            if (index === 0) {\r\n                indicies.push(index);\r\n                return types.push(AL);\r\n            }\r\n\r\n            // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of\r\n            // the base character in all of the following rules. Treat ZWJ as if it were CM.\r\n            var prev = types[index - 1];\r\n            if (LINE_BREAKS.indexOf(prev) === -1) {\r\n                indicies.push(indicies[index - 1]);\r\n                return types.push(prev);\r\n            }\r\n            indicies.push(index);\r\n            return types.push(AL);\r\n        }\r\n\r\n        indicies.push(index);\r\n\r\n        if (classType === CJ) {\r\n            return types.push(lineBreak === 'strict' ? NS : ID);\r\n        }\r\n\r\n        if (classType === SA) {\r\n            return types.push(AL);\r\n        }\r\n\r\n        if (classType === AI) {\r\n            return types.push(AL);\r\n        }\r\n\r\n        // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL\r\n        // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised\r\n        // to take into account the actual line breaking properties for these characters.\r\n        if (classType === XX) {\r\n            if (codePoint >= 0x20000 && codePoint <= 0x2fffd || codePoint >= 0x30000 && codePoint <= 0x3fffd) {\r\n                return types.push(ID);\r\n            } else {\r\n                return types.push(AL);\r\n            }\r\n        }\r\n\r\n        types.push(classType);\r\n    });\r\n\r\n    return [indicies, types, categories];\r\n};\r\n\r\nvar isAdjacentWithSpaceIgnored = function isAdjacentWithSpaceIgnored(a, b, currentIndex, classTypes) {\r\n    var current = classTypes[currentIndex];\r\n    if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {\r\n        var i = currentIndex;\r\n        while (i <= classTypes.length) {\r\n            i++;\r\n            var next = classTypes[i];\r\n\r\n            if (next === b) {\r\n                return true;\r\n            }\r\n\r\n            if (next !== SP) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (current === SP) {\r\n        var _i = currentIndex;\r\n\r\n        while (_i > 0) {\r\n            _i--;\r\n            var prev = classTypes[_i];\r\n\r\n            if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {\r\n                var n = currentIndex;\r\n                while (n <= classTypes.length) {\r\n                    n++;\r\n                    var _next = classTypes[n];\r\n\r\n                    if (_next === b) {\r\n                        return true;\r\n                    }\r\n\r\n                    if (_next !== SP) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (prev !== SP) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar previousNonSpaceClassType = function previousNonSpaceClassType(currentIndex, classTypes) {\r\n    var i = currentIndex;\r\n    while (i >= 0) {\r\n        var type = classTypes[i];\r\n        if (type === SP) {\r\n            i--;\r\n        } else {\r\n            return type;\r\n        }\r\n    }\r\n    return 0;\r\n};\r\n\r\nvar _lineBreakAtIndex = function _lineBreakAtIndex(codePoints, classTypes, indicies, index, forbiddenBreaks) {\r\n    if (indicies[index] === 0) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    var currentIndex = index - 1;\r\n    if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    var beforeIndex = currentIndex - 1;\r\n    var afterIndex = currentIndex + 1;\r\n    var current = classTypes[currentIndex];\r\n\r\n    // LB4 Always break after hard line breaks.\r\n    // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.\r\n    var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;\r\n    var next = classTypes[afterIndex];\r\n\r\n    if (current === CR && next === LF) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    if (HARD_LINE_BREAKS.indexOf(current) !== -1) {\r\n        return BREAK_MANDATORY;\r\n    }\r\n\r\n    // LB6 Do not break before hard line breaks.\r\n    if (HARD_LINE_BREAKS.indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB7 Do not break before spaces or zero width space.\r\n    if (SPACE.indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.\r\n    if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {\r\n        return BREAK_ALLOWED;\r\n    }\r\n\r\n    // LB8a Do not break between a zero width joiner and an ideograph, emoji base or emoji modifier.\r\n    if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ && (next === ID || next === EB || next === EM)) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB11 Do not break before or after Word joiner and related characters.\r\n    if (current === WJ || next === WJ) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB12 Do not break after NBSP and related characters.\r\n    if (current === GL) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.\r\n    if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.\r\n    if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB14 Do not break after ‘[’, even after spaces.\r\n    if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB15 Do not break within ‘”[’, even with intervening spaces.\r\n    if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.\r\n    if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB17 Do not break within ‘——’, even with intervening spaces.\r\n    if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB18 Break after spaces.\r\n    if (current === SP) {\r\n        return BREAK_ALLOWED;\r\n    }\r\n\r\n    // LB19 Do not break before or after quotation marks, such as ‘ ” ’.\r\n    if (current === QU || next === QU) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB20 Break before and after unresolved CB.\r\n    if (next === CB || current === CB) {\r\n        return BREAK_ALLOWED;\r\n    }\r\n\r\n    // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.\r\n    if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB21a Don't break after Hebrew + Hyphen.\r\n    if (before === HL && HYPHEN.indexOf(current) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB21b Don’t break between Solidus and Hebrew letters.\r\n    if (current === SY && next === HL) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB22 Do not break between two ellipses, or between letters, numbers or exclamations and ellipsis.\r\n    if (next === IN && ALPHABETICS.concat(IN, EX, NU, ID, EB, EM).indexOf(current) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB23 Do not break between digits and letters.\r\n    if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.\r\n    if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.\r\n    if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB25 Do not break between the following pairs of classes relevant to numbers:\r\n    if (\r\n    // (PR | PO) × ( OP | HY )? NU\r\n    [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) ||\r\n    // ( OP | HY ) × NU\r\n    [OP, HY].indexOf(current) !== -1 && next === NU ||\r\n    // NU ×\t(NU | SY | IS)\r\n    current === NU && [NU, SY, IS].indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)\r\n    if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {\r\n        var prevIndex = currentIndex;\r\n        while (prevIndex >= 0) {\r\n            var type = classTypes[prevIndex];\r\n            if (type === NU) {\r\n                return BREAK_NOT_ALLOWED;\r\n            } else if ([SY, IS].indexOf(type) !== -1) {\r\n                prevIndex--;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))\r\n    if ([PR, PO].indexOf(next) !== -1) {\r\n        var _prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;\r\n        while (_prevIndex >= 0) {\r\n            var _type = classTypes[_prevIndex];\r\n            if (_type === NU) {\r\n                return BREAK_NOT_ALLOWED;\r\n            } else if ([SY, IS].indexOf(_type) !== -1) {\r\n                _prevIndex--;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // LB26 Do not break a Korean syllable.\r\n    if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB27 Treat a Korean Syllable Block the same as ID.\r\n    if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB28 Do not break between alphabetics (“at”).\r\n    if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).\r\n    if (current === IS && ALPHABETICS.indexOf(next) !== -1) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.\r\n    if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB30a Break between two regional indicator symbols if and only if there are an even number of regional\r\n    // indicators preceding the position of the break.\r\n    if (current === RI && next === RI) {\r\n        var i = indicies[currentIndex];\r\n        var count = 1;\r\n        while (i > 0) {\r\n            i--;\r\n            if (classTypes[i] === RI) {\r\n                count++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if (count % 2 !== 0) {\r\n            return BREAK_NOT_ALLOWED;\r\n        }\r\n    }\r\n\r\n    // LB30b Do not break between an emoji base and an emoji modifier.\r\n    if (current === EB && next === EM) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    return BREAK_ALLOWED;\r\n};\r\n\r\nvar lineBreakAtIndex = exports.lineBreakAtIndex = function lineBreakAtIndex(codePoints, index) {\r\n    // LB2 Never break at the start of text.\r\n    if (index === 0) {\r\n        return BREAK_NOT_ALLOWED;\r\n    }\r\n\r\n    // LB3 Always break at the end of text.\r\n    if (index >= codePoints.length) {\r\n        return BREAK_MANDATORY;\r\n    }\r\n\r\n    var _codePointsToCharacte = codePointsToCharacterClasses(codePoints),\r\n        _codePointsToCharacte2 = _slicedToArray(_codePointsToCharacte, 2),\r\n        indicies = _codePointsToCharacte2[0],\r\n        classTypes = _codePointsToCharacte2[1];\r\n\r\n    return _lineBreakAtIndex(codePoints, classTypes, indicies, index);\r\n};\r\n\r\nvar cssFormattedClasses = function cssFormattedClasses(codePoints, options) {\r\n    if (!options) {\r\n        options = { lineBreak: 'normal', wordBreak: 'normal' };\r\n    }\r\n\r\n    var _codePointsToCharacte3 = codePointsToCharacterClasses(codePoints, options.lineBreak),\r\n        _codePointsToCharacte4 = _slicedToArray(_codePointsToCharacte3, 3),\r\n        indicies = _codePointsToCharacte4[0],\r\n        classTypes = _codePointsToCharacte4[1],\r\n        isLetterNumber = _codePointsToCharacte4[2];\r\n\r\n    if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {\r\n        classTypes = classTypes.map(function (type) {\r\n            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;\r\n        });\r\n    }\r\n\r\n    var forbiddenBreakpoints = options.wordBreak === 'keep-all' ? isLetterNumber.map(function (isLetterNumber, i) {\r\n        return isLetterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;\r\n    }) : null;\r\n\r\n    return [indicies, classTypes, forbiddenBreakpoints];\r\n};\r\n\r\nvar inlineBreakOpportunities = exports.inlineBreakOpportunities = function inlineBreakOpportunities(str, options) {\r\n    var codePoints = (0, _Util.toCodePoints)(str);\r\n    var output = BREAK_NOT_ALLOWED;\r\n\r\n    var _cssFormattedClasses = cssFormattedClasses(codePoints, options),\r\n        _cssFormattedClasses2 = _slicedToArray(_cssFormattedClasses, 3),\r\n        indicies = _cssFormattedClasses2[0],\r\n        classTypes = _cssFormattedClasses2[1],\r\n        forbiddenBreakpoints = _cssFormattedClasses2[2];\r\n\r\n    codePoints.forEach(function (codePoint, i) {\r\n        output += (0, _Util.fromCodePoint)(codePoint) + (i >= codePoints.length - 1 ? BREAK_MANDATORY : _lineBreakAtIndex(codePoints, classTypes, indicies, i + 1, forbiddenBreakpoints));\r\n    });\r\n\r\n    return output;\r\n};\r\n\r\nvar Break = function () {\r\n    function Break(codePoints, lineBreak, start, end) {\r\n        _classCallCheck(this, Break);\r\n\r\n        this._codePoints = codePoints;\r\n        this.required = lineBreak === BREAK_MANDATORY;\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n\r\n    _createClass(Break, [{\r\n        key: 'slice',\r\n        value: function slice() {\r\n            return _Util.fromCodePoint.apply(undefined, _toConsumableArray(this._codePoints.slice(this.start, this.end)));\r\n        }\r\n    }]);\r\n\r\n    return Break;\r\n}();\r\n\r\nvar LineBreaker = exports.LineBreaker = function LineBreaker(str, options) {\r\n    var codePoints = (0, _Util.toCodePoints)(str);\r\n\r\n    var _cssFormattedClasses3 = cssFormattedClasses(codePoints, options),\r\n        _cssFormattedClasses4 = _slicedToArray(_cssFormattedClasses3, 3),\r\n        indicies = _cssFormattedClasses4[0],\r\n        classTypes = _cssFormattedClasses4[1],\r\n        forbiddenBreakpoints = _cssFormattedClasses4[2];\r\n\r\n    var length = codePoints.length;\r\n    var lastEnd = 0;\r\n    var nextIndex = 0;\r\n\r\n    return {\r\n        next: function next() {\r\n            if (nextIndex >= length) {\r\n                return { done: true };\r\n            }\r\n            var lineBreak = BREAK_NOT_ALLOWED;\r\n            while (nextIndex < length && (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED) {}\r\n\r\n            if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {\r\n                var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);\r\n                lastEnd = nextIndex;\r\n                return { value: value, done: false };\r\n            }\r\n\r\n            return { done: true };\r\n        }\r\n    };\r\n};",null]}