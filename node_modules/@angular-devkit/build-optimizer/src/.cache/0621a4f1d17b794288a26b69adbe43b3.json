{"remainingRequest":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\html2canvas\\dist\\npm\\Gradient.js","dependencies":[{"path":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\html2canvas\\dist\\npm\\Gradient.js","mtime":1549298997489},{"path":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1549298993416},{"path":"D:\\Desenvolvimento\\OBAADM-WEB\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1549298984589}],"contextDependencies":[],"result":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\nexports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _NodeContainer = require('./NodeContainer');\r\n\r\nvar _NodeContainer2 = _interopRequireDefault(_NodeContainer);\r\n\r\nvar _Angle = require('./Angle');\r\n\r\nvar _Color = require('./Color');\r\n\r\nvar _Color2 = _interopRequireDefault(_Color);\r\n\r\nvar _Length = require('./Length');\r\n\r\nvar _Length2 = _interopRequireDefault(_Length);\r\n\r\nvar _Util = require('./Util');\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;\r\nvar PERCENTAGE_ANGLES = /^([+-]?\\d*\\.?\\d+)% ([+-]?\\d*\\.?\\d+)%$/i;\r\nvar ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;\r\nvar FROM_TO_COLORSTOP = /^(from|to|color-stop)\\((?:([\\d.]+)(%)?,\\s*)?(.+?)\\)$/i;\r\nvar RADIAL_SHAPE_DEFINITION = /^\\s*(circle|ellipse)?\\s*((?:([\\d.]+)(px|r?em|%)\\s*(?:([\\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\\s*(?:at\\s*(?:(left|center|right)|([\\d.]+)(px|r?em|%))\\s+(?:(top|center|bottom)|([\\d.]+)(px|r?em|%)))?(?:\\s|$)/i;\r\n\r\nvar GRADIENT_TYPE = exports.GRADIENT_TYPE = {\r\n    LINEAR_GRADIENT: 0,\r\n    RADIAL_GRADIENT: 1\r\n};\r\n\r\nvar RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {\r\n    CIRCLE: 0,\r\n    ELLIPSE: 1\r\n};\r\n\r\nvar LENGTH_FOR_POSITION = {\r\n    left: new _Length2.default('0%'),\r\n    top: new _Length2.default('0%'),\r\n    center: new _Length2.default('50%'),\r\n    right: new _Length2.default('100%'),\r\n    bottom: new _Length2.default('100%')\r\n};\r\n\r\nvar LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {\r\n    _classCallCheck(this, LinearGradient);\r\n\r\n    this.type = GRADIENT_TYPE.LINEAR_GRADIENT;\r\n    this.colorStops = colorStops;\r\n    this.direction = direction;\r\n};\r\n\r\nvar RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {\r\n    _classCallCheck(this, RadialGradient);\r\n\r\n    this.type = GRADIENT_TYPE.RADIAL_GRADIENT;\r\n    this.colorStops = colorStops;\r\n    this.shape = shape;\r\n    this.center = center;\r\n    this.radius = radius;\r\n};\r\n\r\nvar parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {\r\n    var args = _ref.args,\r\n        method = _ref.method,\r\n        prefix = _ref.prefix;\r\n\r\n    if (method === 'linear-gradient') {\r\n        return parseLinearGradient(args, bounds, !!prefix);\r\n    } else if (method === 'gradient' && args[0] === 'linear') {\r\n        // TODO handle correct angle\r\n        return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);\r\n    } else if (method === 'radial-gradient') {\r\n        return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);\r\n    } else if (method === 'gradient' && args[0] === 'radial') {\r\n        return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);\r\n    }\r\n};\r\n\r\nvar parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {\r\n    var colorStops = [];\r\n\r\n    for (var i = firstColorStopIndex; i < args.length; i++) {\r\n        var value = args[i];\r\n        var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);\r\n        var lastSpaceIndex = value.lastIndexOf(' ');\r\n        var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);\r\n        var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;\r\n        colorStops.push({ color: _color, stop: _stop });\r\n    }\r\n\r\n    var absoluteValuedColorStops = colorStops.map(function (_ref2) {\r\n        var color = _ref2.color,\r\n            stop = _ref2.stop;\r\n\r\n        var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;\r\n\r\n        return {\r\n            color: color,\r\n            // $FlowFixMe\r\n            stop: absoluteStop\r\n        };\r\n    });\r\n\r\n    var previousColorStop = absoluteValuedColorStops[0].stop;\r\n    for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {\r\n        if (previousColorStop !== null) {\r\n            var _stop2 = absoluteValuedColorStops[_i].stop;\r\n            if (_stop2 === null) {\r\n                var n = _i;\r\n                while (absoluteValuedColorStops[n].stop === null) {\r\n                    n++;\r\n                }\r\n                var steps = n - _i + 1;\r\n                var nextColorStep = absoluteValuedColorStops[n].stop;\r\n                var stepSize = (nextColorStep - previousColorStop) / steps;\r\n                for (; _i < n; _i++) {\r\n                    previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;\r\n                }\r\n            } else {\r\n                previousColorStop = _stop2;\r\n            }\r\n        }\r\n    }\r\n\r\n    return absoluteValuedColorStops;\r\n};\r\n\r\nvar parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {\r\n    var angle = (0, _Angle.parseAngle)(args[0]);\r\n    var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);\r\n    var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);\r\n    var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection(\r\n    // if there is a prefix, the 0° angle points due East (instead of North per W3C)\r\n    hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);\r\n    var firstColorStopIndex = HAS_DIRECTION ? 1 : 0;\r\n\r\n    // TODO: Fix some inaccuracy with color stops with px values\r\n    var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);\r\n\r\n    return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);\r\n};\r\n\r\nvar parseRadialGradient = function parseRadialGradient(container, args, bounds) {\r\n    var m = args[0].match(RADIAL_SHAPE_DEFINITION);\r\n    var shape = m && (m[1] === 'circle' || // explicit shape specification\r\n    m[3] !== undefined && m[5] === undefined) // only one radius coordinate\r\n    ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;\r\n    var radius = {};\r\n    var center = {};\r\n\r\n    if (m) {\r\n        // Radius\r\n        if (m[3] !== undefined) {\r\n            radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);\r\n        }\r\n\r\n        if (m[5] !== undefined) {\r\n            radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);\r\n        }\r\n\r\n        // Position\r\n        if (m[7]) {\r\n            center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];\r\n        } else if (m[8] !== undefined) {\r\n            center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);\r\n        }\r\n\r\n        if (m[10]) {\r\n            center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];\r\n        } else if (m[11] !== undefined) {\r\n            center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);\r\n        }\r\n    }\r\n\r\n    var gradientCenter = {\r\n        x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),\r\n        y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)\r\n    };\r\n    var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);\r\n\r\n    return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);\r\n};\r\n\r\nvar calculateGradientDirection = function calculateGradientDirection(radian, bounds) {\r\n    var width = bounds.width;\r\n    var height = bounds.height;\r\n    var HALF_WIDTH = width * 0.5;\r\n    var HALF_HEIGHT = height * 0.5;\r\n    var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\r\n    var HALF_LINE_LENGTH = lineLength / 2;\r\n\r\n    var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;\r\n    var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;\r\n    var x1 = width - x0;\r\n    var y1 = height - y0;\r\n\r\n    return { x0: x0, x1: x1, y0: y0, y1: y1 };\r\n};\r\n\r\nvar parseTopRight = function parseTopRight(bounds) {\r\n    return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));\r\n};\r\n\r\nvar parseSideOrCorner = function parseSideOrCorner(side, bounds) {\r\n    switch (side) {\r\n        case 'bottom':\r\n        case 'to top':\r\n            return calculateGradientDirection(0, bounds);\r\n        case 'left':\r\n        case 'to right':\r\n            return calculateGradientDirection(Math.PI / 2, bounds);\r\n        case 'right':\r\n        case 'to left':\r\n            return calculateGradientDirection(3 * Math.PI / 2, bounds);\r\n        case 'top right':\r\n        case 'right top':\r\n        case 'to bottom left':\r\n        case 'to left bottom':\r\n            return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);\r\n        case 'top left':\r\n        case 'left top':\r\n        case 'to bottom right':\r\n        case 'to right bottom':\r\n            return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);\r\n        case 'bottom left':\r\n        case 'left bottom':\r\n        case 'to top right':\r\n        case 'to right top':\r\n            return calculateGradientDirection(parseTopRight(bounds), bounds);\r\n        case 'bottom right':\r\n        case 'right bottom':\r\n        case 'to top left':\r\n        case 'to left top':\r\n            return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);\r\n        case 'top':\r\n        case 'to bottom':\r\n        default:\r\n            return calculateGradientDirection(Math.PI, bounds);\r\n    }\r\n};\r\n\r\nvar parsePercentageAngle = function parsePercentageAngle(angle, bounds) {\r\n    var _angle$split$map = angle.split(' ').map(parseFloat),\r\n        _angle$split$map2 = _slicedToArray(_angle$split$map, 2),\r\n        left = _angle$split$map2[0],\r\n        top = _angle$split$map2[1];\r\n\r\n    var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);\r\n\r\n    return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);\r\n};\r\n\r\nvar findCorner = function findCorner(bounds, x, y, closest) {\r\n    var corners = [{ x: 0, y: 0 }, { x: 0, y: bounds.height }, { x: bounds.width, y: 0 }, { x: bounds.width, y: bounds.height }];\r\n\r\n    // $FlowFixMe\r\n    return corners.reduce(function (stat, corner) {\r\n        var d = (0, _Util.distance)(x - corner.x, y - corner.y);\r\n        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\r\n            return {\r\n                optimumCorner: corner,\r\n                optimumDistance: d\r\n            };\r\n        }\r\n\r\n        return stat;\r\n    }, {\r\n        optimumDistance: closest ? Infinity : -Infinity,\r\n        optimumCorner: null\r\n    }).optimumCorner;\r\n};\r\n\r\nvar calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {\r\n    var x = center.x;\r\n    var y = center.y;\r\n    var rx = 0;\r\n    var ry = 0;\r\n\r\n    switch (extent) {\r\n        case 'closest-side':\r\n            // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.\r\n            // If the shape is an ellipse, it exactly meets the closest side in each dimension.\r\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\r\n                rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\r\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\r\n                rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));\r\n                ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));\r\n            }\r\n            break;\r\n\r\n        case 'closest-corner':\r\n            // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.\r\n            // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\r\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\r\n                rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\r\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\r\n                // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\r\n                var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));\r\n                var corner = findCorner(bounds, x, y, true);\r\n                rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);\r\n                ry = c * rx;\r\n            }\r\n            break;\r\n\r\n        case 'farthest-side':\r\n            // Same as closest-side, except the ending shape is sized based on the farthest side(s)\r\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\r\n                rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\r\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\r\n                rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));\r\n                ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));\r\n            }\r\n            break;\r\n\r\n        case 'farthest-corner':\r\n            // Same as closest-corner, except the ending shape is sized based on the farthest corner.\r\n            // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\r\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\r\n                rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\r\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\r\n                // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\r\n                var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));\r\n                var _corner = findCorner(bounds, x, y, false);\r\n                rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);\r\n                ry = _c * rx;\r\n            }\r\n            break;\r\n\r\n        default:\r\n            // pixel or percentage values\r\n            rx = radius.x || 0;\r\n            ry = radius.y !== undefined ? radius.y : rx;\r\n            break;\r\n    }\r\n\r\n    return {\r\n        x: rx,\r\n        y: ry\r\n    };\r\n};\r\n\r\nvar transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {\r\n    var shape = '';\r\n    var radius = '';\r\n    var extent = '';\r\n    var position = '';\r\n    var idx = 0;\r\n\r\n    var POSITION = /^(left|center|right|\\d+(?:px|r?em|%)?)(?:\\s+(top|center|bottom|\\d+(?:px|r?em|%)?))?$/i;\r\n    var SHAPE_AND_EXTENT = /^(circle|ellipse)?\\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;\r\n    var RADIUS = /^\\d+(px|r?em|%)?(?:\\s+\\d+(px|r?em|%)?)?$/i;\r\n\r\n    var matchStartPosition = args[idx].match(POSITION);\r\n    if (matchStartPosition) {\r\n        idx++;\r\n    }\r\n\r\n    var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);\r\n    if (matchShapeExtent) {\r\n        shape = matchShapeExtent[1] || '';\r\n        extent = matchShapeExtent[2] || '';\r\n        if (extent === 'contain') {\r\n            extent = 'closest-side';\r\n        } else if (extent === 'cover') {\r\n            extent = 'farthest-corner';\r\n        }\r\n        idx++;\r\n    }\r\n\r\n    var matchStartRadius = args[idx].match(RADIUS);\r\n    if (matchStartRadius) {\r\n        idx++;\r\n    }\r\n\r\n    var matchEndPosition = args[idx].match(POSITION);\r\n    if (matchEndPosition) {\r\n        idx++;\r\n    }\r\n\r\n    var matchEndRadius = args[idx].match(RADIUS);\r\n    if (matchEndRadius) {\r\n        idx++;\r\n    }\r\n\r\n    var matchPosition = matchEndPosition || matchStartPosition;\r\n    if (matchPosition && matchPosition[1]) {\r\n        position = matchPosition[1] + (/^\\d+$/.test(matchPosition[1]) ? 'px' : '');\r\n        if (matchPosition[2]) {\r\n            position += ' ' + matchPosition[2] + (/^\\d+$/.test(matchPosition[2]) ? 'px' : '');\r\n        }\r\n    }\r\n\r\n    var matchRadius = matchEndRadius || matchStartRadius;\r\n    if (matchRadius) {\r\n        radius = matchRadius[0];\r\n        if (!matchRadius[1]) {\r\n            radius += 'px';\r\n        }\r\n    }\r\n\r\n    if (position && !shape && !radius && !extent) {\r\n        radius = position;\r\n        position = '';\r\n    }\r\n\r\n    if (position) {\r\n        position = 'at ' + position;\r\n    }\r\n\r\n    return [[shape, extent, radius, position].filter(function (s) {\r\n        return !!s;\r\n    }).join(' ')].concat(args.slice(idx));\r\n};\r\n\r\nvar transformObsoleteColorStops = function transformObsoleteColorStops(args) {\r\n    return args.map(function (color) {\r\n        return color.match(FROM_TO_COLORSTOP);\r\n    })\r\n    // $FlowFixMe\r\n    .map(function (v, index) {\r\n        if (!v) {\r\n            return args[index];\r\n        }\r\n\r\n        switch (v[1]) {\r\n            case 'from':\r\n                return v[4] + ' 0%';\r\n            case 'to':\r\n                return v[4] + ' 100%';\r\n            case 'color-stop':\r\n                if (v[3] === '%') {\r\n                    return v[4] + ' ' + v[2];\r\n                }\r\n                return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';\r\n        }\r\n    });\r\n};",null]}