{"remainingRequest":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/html2canvas/dist/npm/Bounds.js","dependencies":[{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/html2canvas/dist/npm/Bounds.js","mtime":1549298997000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/cache-loader/dist/cjs.js","mtime":1549298993000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1549298984000}],"contextDependencies":[],"result":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\nexports.parseBoundCurves = exports.calculatePaddingBoxPath = exports.calculateBorderBoxPath = exports.parsePathForBorder = exports.parseDocumentSize = exports.calculateContentBox = exports.calculatePaddingBox = exports.parseBounds = exports.Bounds = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _Vector = require('./drawing/Vector');\r\n\r\nvar _Vector2 = _interopRequireDefault(_Vector);\r\n\r\nvar _BezierCurve = require('./drawing/BezierCurve');\r\n\r\nvar _BezierCurve2 = _interopRequireDefault(_BezierCurve);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar TOP = 0;\r\nvar RIGHT = 1;\r\nvar BOTTOM = 2;\r\nvar LEFT = 3;\r\n\r\nvar H = 0;\r\nvar V = 1;\r\n\r\nvar Bounds = exports.Bounds = function () {\r\n    function Bounds(x, y, w, h) {\r\n        _classCallCheck(this, Bounds);\r\n\r\n        this.left = x;\r\n        this.top = y;\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n\r\n    _createClass(Bounds, null, [{\r\n        key: 'fromClientRect',\r\n        value: function fromClientRect(clientRect, scrollX, scrollY) {\r\n            return new Bounds(clientRect.left + scrollX, clientRect.top + scrollY, clientRect.width, clientRect.height);\r\n        }\r\n    }]);\r\n\r\n    return Bounds;\r\n}();\r\n\r\nvar parseBounds = exports.parseBounds = function parseBounds(node, scrollX, scrollY) {\r\n    return Bounds.fromClientRect(node.getBoundingClientRect(), scrollX, scrollY);\r\n};\r\n\r\nvar calculatePaddingBox = exports.calculatePaddingBox = function calculatePaddingBox(bounds, borders) {\r\n    return new Bounds(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth, bounds.width - (borders[RIGHT].borderWidth + borders[LEFT].borderWidth), bounds.height - (borders[TOP].borderWidth + borders[BOTTOM].borderWidth));\r\n};\r\n\r\nvar calculateContentBox = exports.calculateContentBox = function calculateContentBox(bounds, padding, borders) {\r\n    // TODO support percentage paddings\r\n    var paddingTop = padding[TOP].value;\r\n    var paddingRight = padding[RIGHT].value;\r\n    var paddingBottom = padding[BOTTOM].value;\r\n    var paddingLeft = padding[LEFT].value;\r\n\r\n    return new Bounds(bounds.left + paddingLeft + borders[LEFT].borderWidth, bounds.top + paddingTop + borders[TOP].borderWidth, bounds.width - (borders[RIGHT].borderWidth + borders[LEFT].borderWidth + paddingLeft + paddingRight), bounds.height - (borders[TOP].borderWidth + borders[BOTTOM].borderWidth + paddingTop + paddingBottom));\r\n};\r\n\r\nvar parseDocumentSize = exports.parseDocumentSize = function parseDocumentSize(document) {\r\n    var body = document.body;\r\n    var documentElement = document.documentElement;\r\n\r\n    if (!body || !documentElement) {\r\n        throw new Error(process.env.NODE_ENV !== 'production' ? 'Unable to get document size' : '');\r\n    }\r\n    var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));\r\n\r\n    var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));\r\n\r\n    return new Bounds(0, 0, width, height);\r\n};\r\n\r\nvar parsePathForBorder = exports.parsePathForBorder = function parsePathForBorder(curves, borderSide) {\r\n    switch (borderSide) {\r\n        case TOP:\r\n            return createPathFromCurves(curves.topLeftOuter, curves.topLeftInner, curves.topRightOuter, curves.topRightInner);\r\n        case RIGHT:\r\n            return createPathFromCurves(curves.topRightOuter, curves.topRightInner, curves.bottomRightOuter, curves.bottomRightInner);\r\n        case BOTTOM:\r\n            return createPathFromCurves(curves.bottomRightOuter, curves.bottomRightInner, curves.bottomLeftOuter, curves.bottomLeftInner);\r\n        case LEFT:\r\n        default:\r\n            return createPathFromCurves(curves.bottomLeftOuter, curves.bottomLeftInner, curves.topLeftOuter, curves.topLeftInner);\r\n    }\r\n};\r\n\r\nvar createPathFromCurves = function createPathFromCurves(outer1, inner1, outer2, inner2) {\r\n    var path = [];\r\n    if (outer1 instanceof _BezierCurve2.default) {\r\n        path.push(outer1.subdivide(0.5, false));\r\n    } else {\r\n        path.push(outer1);\r\n    }\r\n\r\n    if (outer2 instanceof _BezierCurve2.default) {\r\n        path.push(outer2.subdivide(0.5, true));\r\n    } else {\r\n        path.push(outer2);\r\n    }\r\n\r\n    if (inner2 instanceof _BezierCurve2.default) {\r\n        path.push(inner2.subdivide(0.5, true).reverse());\r\n    } else {\r\n        path.push(inner2);\r\n    }\r\n\r\n    if (inner1 instanceof _BezierCurve2.default) {\r\n        path.push(inner1.subdivide(0.5, false).reverse());\r\n    } else {\r\n        path.push(inner1);\r\n    }\r\n\r\n    return path;\r\n};\r\n\r\nvar calculateBorderBoxPath = exports.calculateBorderBoxPath = function calculateBorderBoxPath(curves) {\r\n    return [curves.topLeftOuter, curves.topRightOuter, curves.bottomRightOuter, curves.bottomLeftOuter];\r\n};\r\n\r\nvar calculatePaddingBoxPath = exports.calculatePaddingBoxPath = function calculatePaddingBoxPath(curves) {\r\n    return [curves.topLeftInner, curves.topRightInner, curves.bottomRightInner, curves.bottomLeftInner];\r\n};\r\n\r\nvar parseBoundCurves = exports.parseBoundCurves = function parseBoundCurves(bounds, borders, borderRadius) {\r\n    var tlh = borderRadius[CORNER.TOP_LEFT][H].getAbsoluteValue(bounds.width);\r\n    var tlv = borderRadius[CORNER.TOP_LEFT][V].getAbsoluteValue(bounds.height);\r\n    var trh = borderRadius[CORNER.TOP_RIGHT][H].getAbsoluteValue(bounds.width);\r\n    var trv = borderRadius[CORNER.TOP_RIGHT][V].getAbsoluteValue(bounds.height);\r\n    var brh = borderRadius[CORNER.BOTTOM_RIGHT][H].getAbsoluteValue(bounds.width);\r\n    var brv = borderRadius[CORNER.BOTTOM_RIGHT][V].getAbsoluteValue(bounds.height);\r\n    var blh = borderRadius[CORNER.BOTTOM_LEFT][H].getAbsoluteValue(bounds.width);\r\n    var blv = borderRadius[CORNER.BOTTOM_LEFT][V].getAbsoluteValue(bounds.height);\r\n\r\n    var factors = [];\r\n    factors.push((tlh + trh) / bounds.width);\r\n    factors.push((blh + brh) / bounds.width);\r\n    factors.push((tlv + blv) / bounds.height);\r\n    factors.push((trv + brv) / bounds.height);\r\n    var maxFactor = Math.max.apply(Math, factors);\r\n\r\n    if (maxFactor > 1) {\r\n        tlh /= maxFactor;\r\n        tlv /= maxFactor;\r\n        trh /= maxFactor;\r\n        trv /= maxFactor;\r\n        brh /= maxFactor;\r\n        brv /= maxFactor;\r\n        blh /= maxFactor;\r\n        blv /= maxFactor;\r\n    }\r\n\r\n    var topWidth = bounds.width - trh;\r\n    var rightHeight = bounds.height - brv;\r\n    var bottomWidth = bounds.width - brh;\r\n    var leftHeight = bounds.height - blv;\r\n\r\n    return {\r\n        topLeftOuter: tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new _Vector2.default(bounds.left, bounds.top),\r\n        topLeftInner: tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth, Math.max(0, tlh - borders[LEFT].borderWidth), Math.max(0, tlv - borders[TOP].borderWidth), CORNER.TOP_LEFT) : new _Vector2.default(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth),\r\n        topRightOuter: trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new _Vector2.default(bounds.left + bounds.width, bounds.top),\r\n        topRightInner: trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borders[LEFT].borderWidth), bounds.top + borders[TOP].borderWidth, topWidth > bounds.width + borders[LEFT].borderWidth ? 0 : trh - borders[LEFT].borderWidth, trv - borders[TOP].borderWidth, CORNER.TOP_RIGHT) : new _Vector2.default(bounds.left + bounds.width - borders[RIGHT].borderWidth, bounds.top + borders[TOP].borderWidth),\r\n        bottomRightOuter: brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new _Vector2.default(bounds.left + bounds.width, bounds.top + bounds.height),\r\n        bottomRightInner: brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borders[LEFT].borderWidth), bounds.top + Math.min(rightHeight, bounds.height + borders[TOP].borderWidth), Math.max(0, brh - borders[RIGHT].borderWidth), brv - borders[BOTTOM].borderWidth, CORNER.BOTTOM_RIGHT) : new _Vector2.default(bounds.left + bounds.width - borders[RIGHT].borderWidth, bounds.top + bounds.height - borders[BOTTOM].borderWidth),\r\n        bottomLeftOuter: blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new _Vector2.default(bounds.left, bounds.top + bounds.height),\r\n        bottomLeftInner: blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borders[LEFT].borderWidth, bounds.top + leftHeight, Math.max(0, blh - borders[LEFT].borderWidth), blv - borders[BOTTOM].borderWidth, CORNER.BOTTOM_LEFT) : new _Vector2.default(bounds.left + borders[LEFT].borderWidth, bounds.top + bounds.height - borders[BOTTOM].borderWidth)\r\n    };\r\n};\r\n\r\nvar CORNER = {\r\n    TOP_LEFT: 0,\r\n    TOP_RIGHT: 1,\r\n    BOTTOM_RIGHT: 2,\r\n    BOTTOM_LEFT: 3\r\n};\r\n\r\nvar getCurvePoints = function getCurvePoints(x, y, r1, r2, position) {\r\n    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);\r\n    var ox = r1 * kappa; // control point offset horizontal\r\n    var oy = r2 * kappa; // control point offset vertical\r\n    var xm = x + r1; // x-middle\r\n    var ym = y + r2; // y-middle\r\n\r\n    switch (position) {\r\n        case CORNER.TOP_LEFT:\r\n            return new _BezierCurve2.default(new _Vector2.default(x, ym), new _Vector2.default(x, ym - oy), new _Vector2.default(xm - ox, y), new _Vector2.default(xm, y));\r\n        case CORNER.TOP_RIGHT:\r\n            return new _BezierCurve2.default(new _Vector2.default(x, y), new _Vector2.default(x + ox, y), new _Vector2.default(xm, ym - oy), new _Vector2.default(xm, ym));\r\n        case CORNER.BOTTOM_RIGHT:\r\n            return new _BezierCurve2.default(new _Vector2.default(xm, y), new _Vector2.default(xm, y + oy), new _Vector2.default(x + ox, ym), new _Vector2.default(x, ym));\r\n        case CORNER.BOTTOM_LEFT:\r\n        default:\r\n            return new _BezierCurve2.default(new _Vector2.default(xm, ym), new _Vector2.default(xm - ox, ym), new _Vector2.default(x, y + oy), new _Vector2.default(x, y));\r\n    }\r\n};",null]}