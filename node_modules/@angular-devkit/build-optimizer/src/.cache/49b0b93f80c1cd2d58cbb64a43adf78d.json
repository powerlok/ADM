{"remainingRequest":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/html2canvas/dist/npm/NodeParser.js","dependencies":[{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/html2canvas/dist/npm/NodeParser.js","mtime":1549298997000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/cache-loader/dist/cjs.js","mtime":1549298993000},{"path":"/home/laredo/Área de Trabalho/OBAADM-WEB/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1549298984000}],"contextDependencies":[],"result":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\nexports.NodeParser = undefined;\r\n\r\nvar _StackingContext = require('./StackingContext');\r\n\r\nvar _StackingContext2 = _interopRequireDefault(_StackingContext);\r\n\r\nvar _NodeContainer = require('./NodeContainer');\r\n\r\nvar _NodeContainer2 = _interopRequireDefault(_NodeContainer);\r\n\r\nvar _TextContainer = require('./TextContainer');\r\n\r\nvar _TextContainer2 = _interopRequireDefault(_TextContainer);\r\n\r\nvar _Input = require('./Input');\r\n\r\nvar _ListItem = require('./ListItem');\r\n\r\nvar _listStyle = require('./parsing/listStyle');\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar NodeParser = exports.NodeParser = function NodeParser(node, resourceLoader, logger) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        logger.log('Starting node parsing');\r\n    }\r\n\r\n    var index = 0;\r\n\r\n    var container = new _NodeContainer2.default(node, null, resourceLoader, index++);\r\n    var stack = new _StackingContext2.default(container, null, true);\r\n\r\n    parseNodeTree(node, container, stack, resourceLoader, index);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        logger.log('Finished parsing node tree');\r\n    }\r\n\r\n    return stack;\r\n};\r\n\r\nvar IGNORED_NODE_NAMES = ['SCRIPT', 'HEAD', 'TITLE', 'OBJECT', 'BR', 'OPTION'];\r\n\r\nvar parseNodeTree = function parseNodeTree(node, parent, stack, resourceLoader, index) {\r\n    if (process.env.NODE_ENV !== 'production' && index > 50000) {\r\n        throw new Error('Recursion error while parsing node tree');\r\n    }\r\n\r\n    for (var childNode = node.firstChild, nextNode; childNode; childNode = nextNode) {\r\n        nextNode = childNode.nextSibling;\r\n        var defaultView = childNode.ownerDocument.defaultView;\r\n        if (childNode instanceof defaultView.Text || childNode instanceof Text || defaultView.parent && childNode instanceof defaultView.parent.Text) {\r\n            if (childNode.data.trim().length > 0) {\r\n                parent.childNodes.push(_TextContainer2.default.fromTextNode(childNode, parent));\r\n            }\r\n        } else if (childNode instanceof defaultView.HTMLElement || childNode instanceof HTMLElement || defaultView.parent && childNode instanceof defaultView.parent.HTMLElement) {\r\n            if (IGNORED_NODE_NAMES.indexOf(childNode.nodeName) === -1) {\r\n                var container = new _NodeContainer2.default(childNode, parent, resourceLoader, index++);\r\n                if (container.isVisible()) {\r\n                    if (childNode.tagName === 'INPUT') {\r\n                        // $FlowFixMe\r\n                        (0, _Input.inlineInputElement)(childNode, container);\r\n                    } else if (childNode.tagName === 'TEXTAREA') {\r\n                        // $FlowFixMe\r\n                        (0, _Input.inlineTextAreaElement)(childNode, container);\r\n                    } else if (childNode.tagName === 'SELECT') {\r\n                        // $FlowFixMe\r\n                        (0, _Input.inlineSelectElement)(childNode, container);\r\n                    } else if (container.style.listStyle && container.style.listStyle.listStyleType !== _listStyle.LIST_STYLE_TYPE.NONE) {\r\n                        (0, _ListItem.inlineListItemElement)(childNode, container, resourceLoader);\r\n                    }\r\n\r\n                    var SHOULD_TRAVERSE_CHILDREN = childNode.tagName !== 'TEXTAREA';\r\n                    var treatAsRealStackingContext = createsRealStackingContext(container, childNode);\r\n                    if (treatAsRealStackingContext || createsStackingContext(container)) {\r\n                        // for treatAsRealStackingContext:false, any positioned descendants and descendants\r\n                        // which actually create a new stacking context should be considered part of the parent stacking context\r\n                        var parentStack = treatAsRealStackingContext || container.isPositioned() ? stack.getRealParentStackingContext() : stack;\r\n                        var childStack = new _StackingContext2.default(container, parentStack, treatAsRealStackingContext);\r\n                        parentStack.contexts.push(childStack);\r\n                        if (SHOULD_TRAVERSE_CHILDREN) {\r\n                            parseNodeTree(childNode, container, childStack, resourceLoader, index);\r\n                        }\r\n                    } else {\r\n                        stack.children.push(container);\r\n                        if (SHOULD_TRAVERSE_CHILDREN) {\r\n                            parseNodeTree(childNode, container, stack, resourceLoader, index);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (childNode instanceof defaultView.SVGSVGElement || childNode instanceof SVGSVGElement || defaultView.parent && childNode instanceof defaultView.parent.SVGSVGElement) {\r\n            var _container = new _NodeContainer2.default(childNode, parent, resourceLoader, index++);\r\n            var _treatAsRealStackingContext = createsRealStackingContext(_container, childNode);\r\n            if (_treatAsRealStackingContext || createsStackingContext(_container)) {\r\n                // for treatAsRealStackingContext:false, any positioned descendants and descendants\r\n                // which actually create a new stacking context should be considered part of the parent stacking context\r\n                var _parentStack = _treatAsRealStackingContext || _container.isPositioned() ? stack.getRealParentStackingContext() : stack;\r\n                var _childStack = new _StackingContext2.default(_container, _parentStack, _treatAsRealStackingContext);\r\n                _parentStack.contexts.push(_childStack);\r\n            } else {\r\n                stack.children.push(_container);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar createsRealStackingContext = function createsRealStackingContext(container, node) {\r\n    return container.isRootElement() || container.isPositionedWithZIndex() || container.style.opacity < 1 || container.isTransformed() || isBodyWithTransparentRoot(container, node);\r\n};\r\n\r\nvar createsStackingContext = function createsStackingContext(container) {\r\n    return container.isPositioned() || container.isFloating();\r\n};\r\n\r\nvar isBodyWithTransparentRoot = function isBodyWithTransparentRoot(container, node) {\r\n    return node.nodeName === 'BODY' && container.parent instanceof _NodeContainer2.default && container.parent.style.background.backgroundColor.isTransparent();\r\n};",null]}